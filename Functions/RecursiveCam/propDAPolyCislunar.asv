function [lim,smdLim,coeffPoC,coeffDist,timeelapsed,xTca,x0,metric,dist,convRadius] = ...
              propDAPolyCislunar(DAorder,pocType,metricFlag,u,scale,validateFlag,convRadFlag,pp)

t          = pp.t;
et         = pp.et;
mdLim      = pp.mdLim;
Lsc        = pp.Lsc;
mu         = pp.mu;
HBR        = pp.HBR;
x_pTCA     = pp.x_pTCA;
x_sTCA     = pp.x_sTCA;
P          = pp.P;
PoCLim     = pp.PoCLim;
convRadius = nan;
N = length(pp.t);

fid = fopen('initial_state.dat', 'w');
fprintf(fid, '%2i\n',     N);
fprintf(fid, '%2i\n',     pp.lowThrust);
fprintf(fid, '%2i\n',     DAorder);
fprintf(fid, '%2i\n',     metricFlag);
fprintf(fid, '%2i\n',     pocType);
fprintf(fid, '%40.16f\n', et);
fprintf(fid, '%40.16f\n', Lsc);
fprintf(fid, '%40.16f\n', mu);
fprintf(fid, '%40.16f\n', HBR);
for j = 1:6 
    fprintf(fid, '%40.16f\n', x_pTCA(j));
end
for j = 1:6
    fprintf(fid, '%40.16f\n', x_sTCA(j));
end
for j = 1:3 
    for k = 1:3 
        fprintf(fid, '%40.16f\n', P(j,k));
    end
end
for i = 1:N 
    for j = 1:3 
        fprintf(fid, '%40.16f\n', scale(j,i));
    end
end
for i = 1:N 
    for j = 1:3 
        fprintf(fid, '%40.16f\n', u(j,i));
    end
end
for i = 1:N 
    fprintf(fid, '%40.16f\n', t(i));
end
fclose(fid);
tic
% Run the C++ Executable to perform the DA propagation
if ~validateFlag && ~convRadFlag 
    !wsl ./CppExec/polyPropCislunar
elseif validateFlag && ~convRadFlag
    !wsl ./CppExec/validatePolyCislunar
elseif ~validateFlag && convRadFlag
    !wsl ./CppExec/polyConvRadiusCislunar
    convRadius = load('convRad.dat');
    convRadius = reshape(convRadius,3,N);
    convRadius = min(min(convRadius))*ones(3,N);
else
    error('Invalid flag combination')
end
if convRadFlag; lim=[];smdLim=[];coeffPoC=[];coeffDist=[];timeelapsed=[];xTca=[];x0=[];metric=[];dist=[]; 
    return; 
elseif validateFlag
    lim=[];smdLim=[];coeffPoC=[];coeffDist=[];timeelapsed=[];x0=[];
    a      = load("constPart.dat");                                                         
    xTca   = a(1:6);                                                              % [-] (6,1) Constant part of the propagated state and control
    metric = a(13);
    dist   = a(end-5:end);                                                                  % [-] (1,1) Collision metric with no maneuver
    return; 
end
% Polynomials extraction 
b        = tic;
a        = load("constPart.dat");                                                         
xTca     = a(1:6);                                                              % [-] (6,1) Constant part of the propagated state and control
x0       = a(7:12);                                                             % [-] (6,1) Constant part of the propagated state and control
metric   = a(13);                                                               % [-] (1,1) Collision metric with no maneuver
detPB    = a(14);                                                               % [-] (1,1) Determinant of the combined covariance at TCA (2d)
P_B      = reshape(a(15:18),2,2);                                               % [-] (1,1) Determinant of the combined covariance at TCA (2d)
CGT      = reshape(a(19:end),3*N,3*N);                                               % [-] (1,1) Determinant of the combined covariance at TCA (2d)
[V,D]    = eig(CGT);
[eigVals,o] = sort(diag(D),'descend');
V        = V(:,o); 
% dist     = a(end);                                                                  % [-] (1,1) Collision metric with no maneuver
switch pocType
    case 0
        smdLim   = -2*log(2*PoCLim*sqrt(detPB)/HBR^2);                                  % [-] (1,1) SMD limit computed with Alfriend and Akella's formula applied to PC
    case 1
        smdLim   = PoC2SMD(P_B, HBR, PoCLim, 5, 1, 1e-3, 200);                          % [-] (1,1) SMD limit computed with Chan's formula applied to PC
    otherwise
        error('invalid PoC type')
end
switch  metricFlag
    case 1
        lim = log10(PoCLim);
    case 2
        lim = smdLim;
    case 3
        lim = mdLim^2;
    otherwise
        error('Invalid metric flag')
end
coeffPoC  = struct();
coeffDist = struct();
if ~validateFlag && ~convRadFlag
    coeffPoC  = LoadCOSY('metricPoly.dat',3*N,1,0);
%     coeffDist = LoadCOSY('distance.dat',3*N,1,0);
elseif validateFlag
end
timeelapsed = toc(b);
end